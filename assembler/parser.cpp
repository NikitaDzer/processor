//// Created by User on 04.11.2021.//#include "../include/parser.h"#include <cstring>#include <cctype>#include <cmath>struct Label{   char name[LABEL_NAME_MAX_SIZE];   long to;};static char get_register_index(const char *const start){   dead(start);      const char *iterator = start;      while (isalnum(*iterator++));      unsigned long long register_name = '\0';   memcpy(&register_name, start, iterator - start - 1);      // REGISTERS_NUMBER = 16   switch (register_name)   {      case 'xar':         return 0;            case 'xbr':         return 1;            case 'xcr':         return 2;            case 'xdr':         return 3;            case 'pbr':         return 4;            case 'isr':         return 5;            case 'idr':         return 6;            case 'psr':         return 7;         case '8r':         return 8;         case '9r':         return 9;         case '01r':         return 10;         case '11r':         return 11;         case '21r':         return 12;         case '31r':         return 13;         case '41r':         return 14;         case '51r':         return 15;               default:      {         kill         return -1;      }   }}static inline const char* find_closingBracket(const char *const start){   const char *iterator = start;      while (*iterator != ']')   {      if (*iterator == '\n' || *iterator == '\0')         return nullptr;            iterator += 1;   }      return iterator;}static inline const char* find_closingQuote(const char *const start){   if (*(start + 1) != '\'')      return nullptr;      return start + 1;}static inline const char* skip_spaces(const char *const start){   const char *iterator = start;      while (*iterator == ' ')      iterator += 1;      return iterator;}static inline bool is_command_label(const char command_name[]){   return command_name[ strlen(command_name) - 1 ] == ':';}static error_t write_label_to(Command *const p_command, const char *const argument_string,                              const Label *const labels, const size_t labels_number){   for (size_t i = 0; i < labels_number; i++)   {      if (strcmp(argument_string, labels[i].name) == 0)      {         p_command->argument = labels[i].to;         return 0;      }   }      kill   p_command->argument = -1;      return 1;}static void parse_command_argument_string(const char *const argument_string, Command *const p_command){   dead(argument_string);   dead(p_command);      const char *argument_string_iterator = argument_string;      if (*argument_string_iterator == '[')   {      argument_string_iterator += 1;         if (find_closingBracket(argument_string_iterator) == nullptr)         kill               p_command->is_ram = true;   }   else      p_command->is_ram = false;      argument_string_iterator = skip_spaces(argument_string_iterator);      if (*argument_string_iterator == '\'')   {      argument_string_iterator += 1;            if (find_closingQuote(argument_string_iterator) == nullptr)         kill         p_command->argument    = *argument_string_iterator;      p_command->is_register = false;   }   else if (isalpha(*argument_string_iterator))   {      p_command->argument = get_register_index(argument_string_iterator);            if (p_command->argument == -1)         kill               p_command->is_register = true;   }   else   {      if (sscanf(argument_string_iterator, "%lf", &p_command->argument) == 0)         kill            if (p_command->argument != ceil(p_command->argument))         kill               p_command->is_register = false;   }}#define DEFINE_COMMAND(cmd_name, cmd_key, arguments_number, code)                                                   \      if (strcmp(commands_lexemes_iterator->command_name, #cmd_name) == 0)                                          \      {                                                                                                             \         commands_iterator->key = cmd_key;                                                                          \         \         if (arguments_number >= 1)                                                                                 \            parse_command_argument_string(commands_lexemes_iterator->argument_string, commands_iterator);           \         else if (arguments_number == -1)                                                                           \            write_label_to(commands_iterator, commands_lexemes_iterator->argument_string, labels, labels_counter);  \                                                                                                                    \         commands_iterator += 1;                                                                                    \         continue;                                                                                                  \      }size_t parse(CommandLexemes *const commands_lexemes, const size_t commands_lexemes_number, Command **const p_commands){   dead(commands_lexemes);   dead(p_commands);      Command        *const commands                  = (Command *)calloc(commands_lexemes_number, sizeof(Command));   Label          *const labels                    = (Label   *)calloc(commands_lexemes_number, sizeof(Label));      dead(commands);   dead(labels);      Command              *commands_iterator         = commands;   CommandLexemes       *commands_lexemes_iterator = commands_lexemes;      size_t labels_counter = 0;      for (size_t i = 0; i < commands_lexemes_number; i++)   {      if (commands_lexemes[i].argument_string == nullptr && is_command_label(commands_lexemes[i].command_name))      {         strcpy(labels[labels_counter].name, commands_lexemes[i].command_name);                  labels[labels_counter].name[strlen(labels[labels_counter].name) - 1] = '\0';         labels[labels_counter].to = (long)(i - labels_counter);         labels_counter += 1;            commands_lexemes[i].command_name[0] = '\0';      }   }      for (size_t i = 0; i < commands_lexemes_number; i++, commands_lexemes_iterator++)   {      if (commands_lexemes_iterator->command_name[0] == '\0') //! TODO: make some wrapper         continue;      #include "../cpu/commands_system"      #include "../cpu/commands"               printf("%s, %s\n", commands_lexemes_iterator->command_name, commands_lexemes_iterator->argument_string);      kill   }      free(labels);      *p_commands = commands;      return commands_iterator - commands;}