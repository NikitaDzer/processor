//// Created by User on 04.11.2021.//#include "../include/parser.h"#include <cstring>#include <cctype>#include <cmath>#define DEFINE_COMMAND(cmd_name, cmd_key, arguments_number, code)                                         \      if (strcmp(commands_lexemes_iterator->command_name, #cmd_name) == 0)                                \      {                                                                                                   \         commands_iterator->key = cmd_key;                                                                \                                                                                                          \         if (arguments_number >= 1)                                                                       \            parse_command_argument_string(commands_lexemes_iterator->argument_string, commands_iterator); \                                                                                                          \         continue;                                                                                        \      }static double get_register_index(const char *const start){   dead(start);      const char *iterator = start;      while (isalnum(*iterator++));      unsigned long long register_name = '\0';   memcpy(&register_name, start, iterator - start - 1);      // REGISTERS_NUMBER = 16   switch (register_name)   {      case 'xar':         return 0;            case 'xbr':         return 1;            case 'xcr':         return 2;            case 'xdr':         return 3;            case 'pbr':         return 4;            case 'isr':         return 5;            case 'idr':         return 6;            case 'psr':         return 7;         case '8r':         return 8;         case '9r':         return 9;         case '01r':         return 10;         case '11r':         return 11;         case '21r':         return 12;         case '31r':         return 13;         case '41r':         return 14;         case '51r':         return 15;               default:         return -1;   }}static inline const char* find_closingBracket(const char *const start){   const char *iterator = start;      while (*iterator != ']')   {      if (*iterator == '\0')         return nullptr;            iterator += 1;   }      return iterator;}static inline const char* skip_spaces(const char *const start){   const char *iterator = start;      while (*iterator == ' ')      iterator += 1;      return iterator;}static inline bool is_command_label(const char command_name[]){   return command_name[ strlen(command_name) - 1 ] == ':';}void parse_command_argument_string(const char *const argument_string, Command *const p_command){   dead(argument_string);   dead(p_command);      const char *argument_string_iterator = argument_string;      if (*argument_string_iterator == '[')   {      argument_string_iterator += 1;         if (find_closingBracket(argument_string_iterator) == nullptr)         kill               p_command->is_ram = true;   }   else      p_command->is_ram = false;      argument_string_iterator = skip_spaces(argument_string_iterator);      if (isalpha(*argument_string_iterator))   {      p_command->argument = get_register_index(argument_string_iterator);            if (p_command->argument == -1)         kill               p_command->is_register = true;   }   else   {      if (sscanf(argument_string_iterator, "%lf", &p_command->argument) == 0)         kill            if (p_command->argument != ceil(p_command->argument))         kill               p_command->is_register = false;   }}void parse(const CommandLexemes *const commands_lexemes, const size_t commands_number, Command **p_commands){   dead(commands_lexemes);   dead(p_commands);      Command        *const commands                  = (Command *)calloc(commands_number, sizeof(Command));   Command              *commands_iterator         = commands;   const CommandLexemes *commands_lexemes_iterator = commands_lexemes;      dead(commands);   //   commands[]   //   for (size_t i = 0; i < commands_number; i++)//   {//      if (   commands_lexemes[0].argument_string != nullptr//          && is_command_label(commands_lexemes[i].command_name))//      {//         commands//         free(c)//      }//   }      for (size_t i = 0; i < commands_number; i++, commands_iterator++, commands_lexemes_iterator++)   {      #include "../cpu/commands_system"      #include "../cpu/commands"      //         printf("%s, %s\n", commands_lexemes_iterator->command_name, commands_lexemes_iterator->argument_string);      kill   }      *p_commands = commands;}