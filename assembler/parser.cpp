//// Created by User on 04.11.2021.//#include "../include/parser.h"#include <cstring>#include <cctype>#include <cmath>static double get_register_index(const char *const start){   dead(start);      const char *iterator = start;      while (isalnum(*iterator++));      unsigned long long register_name = '\0';   memcpy(&register_name, start, iterator - start - 1);      // REGISTERS_NUMBER = 16   switch (register_name)   {      case 'xar':      {         return 0;      }            case 'xbr':      {         return 1;      }            case 'xcr':      {         return 2;      }            case 'xdr':      {         return 3;      }            case 'pbr':      {         return 4;      }            case 'isr':      {         return 5;      }            case 'idr':      {         return 6;      }            case 'psr':      {         return 7;      }         default:      {                           return -1;      }   }}static inline const char* find_closingBracket(const char *const start){   const char *iterator = start;      while (*iterator != ']')   {      if (*iterator == '\0')         return nullptr;            iterator += 1;   }      return iterator;}static inline bool is_argument_register(const char *const start, const size_t size){   for (const char *iterator = start; iterator < start + size; iterator++)   {      if (isalpha(*iterator))         return true;   }      return false;}static inline const char* skip_spaces(const char *const start){   const char *iterator = start;      while (*iterator == ' ')      iterator += 1;      return iterator;}void parse_command_argument_string(const char *const argument_string, Command *const p_command){   dead(argument_string);   dead(p_command);      const char *argument_string_iterator = argument_string;      if (*argument_string_iterator == '[')   {      argument_string_iterator += 1;         if (find_closingBracket(argument_string_iterator) == nullptr)         kill               p_command->is_ram = true;   }   else      p_command->is_ram = false;      argument_string_iterator = skip_spaces(argument_string_iterator);      if (isalpha(*argument_string_iterator))   {      p_command->argument = get_register_index(argument_string_iterator);            if (p_command->argument == -1)         kill               p_command->is_register = true;   }   else   {      if (sscanf(argument_string_iterator, "%lf", &p_command->argument) == 0)         kill            if (p_command->argument != ceil(p_command->argument))         kill               p_command->is_register = false;   }}void parse(const CommandLexemes *const commands_lexemes, const size_t commands_number, Command **p_commands){   dead(commands_lexemes);   dead(p_commands);      Command *const commands                         = (Command *)calloc(commands_number, sizeof(Command));   Command       *commands_iterator                = commands;   const CommandLexemes *commands_lexemes_iterator = commands_lexemes;      dead(commands);      for (size_t i = 0; i < commands_number; i++)   {      if (strcmp(commands_lexemes_iterator->command_name, "push") == 0)      {         commands_iterator->key = 1;         parse_command_argument_string(commands_lexemes_iterator->argument_string, commands_iterator);      }      else if (strcmp(commands_lexemes_iterator->command_name, "pop") == 0)      {         commands_iterator->key = 2;         parse_command_argument_string(commands_lexemes_iterator->argument_string, commands_iterator);      }      else if (strcmp(commands_lexemes_iterator->command_name, "sum") == 0)      {         commands_iterator->key = 3;      }      else if (strcmp(commands_lexemes_iterator->command_name, "mul") == 0)      {         commands_iterator->key = 4;      }      else      {         kill      }            commands_iterator         += 1;      commands_lexemes_iterator += 1;   }      *p_commands = commands;}